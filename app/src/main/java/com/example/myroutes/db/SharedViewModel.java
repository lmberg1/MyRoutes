package com.example.myroutes.db;

import android.app.Application;
import android.content.Context;
import android.content.SharedPreferences;

import androidx.annotation.NonNull;
import androidx.lifecycle.AndroidViewModel;
import androidx.lifecycle.LiveData;
import androidx.lifecycle.MediatorLiveData;
import androidx.lifecycle.MutableLiveData;

import com.example.myroutes.db.backends.FileService;
import com.example.myroutes.db.mongoClasses.BoulderItem;
import com.example.myroutes.db.mongoClasses.WallDataItem;
import com.example.myroutes.db.mongoClasses.WallImageItem;
import com.example.myroutes.util.PreferenceManager;
import com.example.myroutes.util.WallMetadata;
import com.mongodb.stitch.core.services.mongodb.remote.RemoteDeleteResult;
import com.mongodb.stitch.core.services.mongodb.remote.RemoteInsertOneResult;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Objects;
import java.util.Set;

public class SharedViewModel extends AndroidViewModel {
    private static final String TAG = "SharedViewModel";

    // Folder for shared preferences
    private static final String PREFERENCE_FOLDER = "Settings";

    // Statuses for fetching/inserting data
    public enum Status {SUCCESS, FAILURE, NOT_FOUND, LOADING};

    // All possible boulder grades
    public static final String[] BOULDER_GRADES = {"V0", "V1", "V2", "V3", "V4", "V5", "V6", "V7", "V8", "V9", "V10"};

    // LiveData to communicate with fragments about status of current wall
    MutableLiveData<Status> currentWallStatus = new MutableLiveData<>();
    private String currentWallId;

    // Stores all currently cached walls under their wall_id
    private HashMap<String, Wall> loadedWalls = new HashMap<>();

    // Preference data
    private String username;                       // User's autogenerated username
    private String default_id;                     // Id of user's default wall
    private MutableLiveData<Set<String>> wall_ids; // Set of wall ids user has access to

    // Repository
    private WallDataRepository wallDataRepository;

    public SharedViewModel(@NonNull Application application) {
        super(application);

        wallDataRepository = new WallDataRepository(application);

        // Initialize preference data
        SharedPreferences preferences = getSharedPreferences();
        username = PreferenceManager.getUser_id(preferences);
        default_id = PreferenceManager.getDefault_wall(preferences);
        wall_ids = new MutableLiveData<>();
        wall_ids.setValue(PreferenceManager.getWall_ids(preferences));
    }

    /*---------------------------------MAIN WALL FUNCTIONS----------------------------------------*/

    public String getCurrentWallId() {
        return currentWallId;
    }

    public LiveData<Status> getCurrentWallStatus() {
        return currentWallStatus;
    }

    public Wall getWall(String wall_id) {
        assert wall_id != null;
        return loadedWalls.getOrDefault(wall_id, null);
    }

    public LiveData<Status> createWall(WallDataItem dataItem, WallImageItem imageItem) {
        assert dataItem != null;
        assert imageItem != null;

        // Immediately add data to cache
        addWallToCache(dataItem, imageItem, new ArrayList<>());

        MediatorLiveData<Status> mediator = new MediatorLiveData<>();
        LiveData<Result<RemoteInsertOneResult>> addData = wallDataRepository.insertWallData(dataItem);
        LiveData<Result<RemoteInsertOneResult>> addImage = wallDataRepository.insertImageData(imageItem);

        // Wait until both data and image have been saved
        waitForAll(addData, addImage)
                .observeForever(o -> {
                    if (o == Status.LOADING) {
                        mediator.setValue(Status.LOADING);
                        return;
                    }
                    mediator.setValue(checkForLoadError(addData, addImage));
                });

        return mediator;
    }

    public LiveData<Status> downloadWall(String wall_id) {
        assert wall_id != null;

        MediatorLiveData<Status> mediator = new MediatorLiveData<>();

        // Try to fetch data, image, and boulders from repository
        LiveData<Result<WallDataItem>> data = wallDataRepository.getWallData(wall_id);
        LiveData<Result<WallImageItem>> image = wallDataRepository.getImageData(wall_id);
        LiveData<Result<List<BoulderItem>>> boulders = wallDataRepository.getBoulders(wall_id);

        // Wait until data, image, and boulders results have loaded
        waitForAll(data, image, boulders)
                .observeForever(o -> {
                    // Check if data is still loading
                    if (o == Status.LOADING) {
                        mediator.setValue(Status.LOADING);
                        return;
                    }
                    // Check if data or image loading resulted in errors
                    Status s = checkForLoadError(data, image);
                    if (s != Status.SUCCESS) {
                        mediator.setValue(s);
                        return;
                    }
                    // No errors so save wall
                    addWallToCache(
                            ((Result.Success<WallDataItem>) Objects.requireNonNull(data.getValue())).getResult(),
                            ((Result.Success<WallImageItem>) Objects.requireNonNull(image.getValue())).getResult(),
                            (boulders.getValue() instanceof Result.Success) ?
                                    ((Result.Success<List<BoulderItem>>) Objects.requireNonNull(boulders.getValue())).getResult() :
                                    new ArrayList<>()
                    );
                    mediator.setValue(Status.SUCCESS);
                });

        return mediator;
    }

    public LiveData<Status> setCurrentWall(String wall_id) {
        assert wall_id != null;

        currentWallStatus.setValue(Status.LOADING);

        // Check if wall is already loaded
        //MutableLiveData<Status> status = new MutableLiveData<>();
        if (loadedWalls.containsKey(wall_id)) {
            currentWallId = wall_id;
            currentWallStatus.setValue(Status.SUCCESS);
            return currentWallStatus;
        }

        // Otherwise we need to download it first
        LiveData<Status> downloadStatus = downloadWall(wall_id);
        //currentWallStatus = (MutableLiveData<Status>) downloadWall(wall_id);
        downloadStatus.observeForever(o -> {
            if (o == Status.SUCCESS) {
                currentWallId = wall_id;
                currentWallStatus.setValue(Status.SUCCESS);
            }
        });

        return currentWallStatus;
    }

    public LiveData<Status> deleteWallPermanent(String wall_id) {
        assert wall_id != null;

        // Remove from device
        deleteWallLocal(wall_id);

        // Delete wall from database
        LiveData<Result<RemoteDeleteResult>> data = wallDataRepository.deleteWallData(wall_id);
        LiveData<Result<RemoteDeleteResult>> image = wallDataRepository.deleteImageData(wall_id);
        LiveData<Result<RemoteDeleteResult>> boulders = wallDataRepository.deleteBoulders(wall_id);

        MediatorLiveData<Status> mediator = new MediatorLiveData<>();
        // Wait until data, image, and boulders have all been deleted
        waitForAll(data, image, boulders)
                .observeForever(o -> {
                    // Deletions are still in progress
                    if (o == Status.LOADING) {
                        mediator.setValue(Status.LOADING);
                        return;
                    }
                    // Deletions are finished, but check if there were any errors
                    mediator.setValue(checkForLoadError(data, image, boulders));
                });
        return mediator;
    }


    public void deleteWallLocal(String wall_id) {
        assert wall_id != null;
        removeWall_id(wall_id);
        FileService.deleteImageFromDevice(wall_id, getApplication());
    }

    /*-----------------------------------HELPER FUNCTIONS-----------------------------------------*/

    // Create LiveData that only returns SUCCESS when all items have loaded, and false otherwise
    private LiveData<Status> waitForAll(LiveData<?>... items) {
        MediatorLiveData<Status> mediator = new MediatorLiveData<>();
        for (LiveData<?> item : items) {
            mediator.addSource(item, o -> {
                // Check if all other items have loaded
                for (LiveData<?> result: items) {
                    if (result.getValue() == null) {
                        mediator.setValue(Status.LOADING);
                        return;
                    }
                }
                mediator.setValue(Status.SUCCESS);
            });
        }
        return mediator;
    }

    // Check for Status errors in each LiveData item
    private Status checkForLoadError(LiveData<?>... items) {
        for (LiveData<?> item : items) {
            // items should always be of type LiveData<Result<?>>
            if (item.getValue() instanceof Result.Error) {
                Result.Error<?> value = (Result.Error<?>) item.getValue();
                return value.getError();
            }
        }
        return Status.SUCCESS;
    }

    // Update variables and shared preferences
    private void addWallToCache(WallDataItem data, WallImageItem image, List<BoulderItem> boulders) {
        Wall wall = new Wall(data, image, orderByGrade(boulders));

        // Update variables
        loadedWalls.putIfAbsent(wall.getId(), wall);
        if (currentWallId == null) {
            currentWallId = wall.getId();
            currentWallStatus.setValue(Status.SUCCESS);
        }

        // Update preferences
        PreferenceManager.Role role = (getStitchUserId().equals(data.getUser_id())) ?
                PreferenceManager.Role.OWNER : PreferenceManager.Role.NON_OWNER;
        Preferences_addWall(data, role);
    }

    public static HashMap<String, List<BoulderItem>> orderByGrade(List<BoulderItem> items) {
        // Initialize hashmap
        HashMap<String, List<BoulderItem>> boulderMap = new HashMap<>();

        // Sort boulders into their correct grade
        for (BoulderItem item : items) {
            String grade = item.getBoulder_grade();
            List<BoulderItem> gradeList = boulderMap.getOrDefault(grade, new ArrayList<>());
            assert gradeList != null;
            gradeList.add(item);
            boulderMap.put(item.getBoulder_grade(), gradeList);
        }

        return boulderMap;
    }

    /*------------------------------------HANDLE BOULDERS-----------------------------------------*/

    public LiveData<Status> addBoulderItem(BoulderItem boulderItem) {
        assert boulderItem != null;

        // Update boulders
        /*String grade = boulderItem.getBoulder_grade();
        Wall currentWall = loadedWalls.get(boulderItem.getWall_id());
        assert currentWall != null;
        List<BoulderItem> boulders = currentWall.boulders.getOrDefault(grade, new ArrayList<>());
        assert boulders != null;
        boulders.add(boulderItem);
        currentWall.boulders.put(grade, boulders);*/
        // Add boulder to wall variables
        Wall wall = loadedWalls.get(boulderItem.getWall_id());
        assert wall != null;
        wall.addBoulder(boulderItem);
        loadedWalls.put(boulderItem.getWall_id(), wall);

        // Add boulder to database
        wallDataRepository.insertBoulder(boulderItem);

        final MutableLiveData<Status> result = new MutableLiveData<>();
        result.setValue(Status.SUCCESS);

        return result;
    }

    /*---------------------------------HANDLE AUTHENTICATION--------------------------------------*/

    public String getStitchUserId() {
        return wallDataRepository.getStitchUserId();
    }

    public LiveData<Status> setStitchUser(String username) {
        return wallDataRepository.setStichUser(username);
    }

    /*----------------------------------HANDLE PREFERENCES----------------------------------------*/

    private SharedPreferences getSharedPreferences() {
        return getApplication().getSharedPreferences(PREFERENCE_FOLDER, Context.MODE_PRIVATE);
    }

    public String getUsername() {
        return username;
    }

    public String getDefault_id() {
        return default_id;
    }

    public LiveData<Set<String>> getWall_ids() {
        return wall_ids;
    }

    public WallMetadata getWall_metadata(String wall_id) {
        return PreferenceManager.getWall_metadata(wall_id, getSharedPreferences());
    }

    public void setUsername(String username) {
        assert username != null;
        this.username = username;
        PreferenceManager.setUser_id(username, getSharedPreferences());
    }

    public void setDefault_id(String default_id) {
        if (!hasWall_id(default_id)) return;
        this.default_id = default_id;
        PreferenceManager.setDefault_wall(default_id, getSharedPreferences());
    }

    public void setWall_metadata(WallMetadata metadata) {
        PreferenceManager.setWall_metadata(metadata, getSharedPreferences());
    }

    public boolean hasWall_id(String wall_id) {
        return this.wall_ids.getValue().contains(wall_id);
    }

    private boolean removeWall_id(String wall_id) {
        assert wall_id != null;
        if (!hasWall_id(wall_id)) { return false; }

        // Get the new set of wall ids after removing wall_id
        Set<String> new_wall_ids = this.wall_ids.getValue();
        assert new_wall_ids != null;
        new_wall_ids.remove(wall_id);

        // Remove wall from cache if it was there
        this.loadedWalls.remove(wall_id);

        // Check if we're trying to delete the default wall
        if (default_id.equals(wall_id)) {
            default_id = (new_wall_ids .size() == 0) ? null : new_wall_ids.iterator().next();
        }

        // Check if we're trying to delete the current wall
        if (wall_id.equals(currentWallId)) {
            // No more walls
            if (default_id == null) { currentWallId = null; }
            // Need to update current wall
            else { setCurrentWall(default_id); }
        }

        // Update value of wall_ids to notify observers that it's changed
        this.wall_ids.setValue(new_wall_ids);

        // Update shared preferences
        PreferenceManager.removeWall_id(wall_id, getSharedPreferences());
        if (default_id != null) PreferenceManager.setDefault_wall(default_id, getSharedPreferences());
        return false;
    }

    private void Preferences_addWall(WallDataItem item, PreferenceManager.Role role) {
        String id = item.getWall_id();

        // Get the new set of wall ids after adding wall_id
        Set<String> new_wall_ids = this.wall_ids.getValue();
        assert new_wall_ids != null;
        new_wall_ids.add(id);

        // Check if there's no default wall set
        if (this.default_id == null) { this.default_id = id; }

        // Update value of wall_ids to notify observers that it's changed
        this.wall_ids.setValue(new_wall_ids);

        // Update shared preferences
        PreferenceManager.addWall_id(
                new WallMetadata(id, item.getWall_name(), role),
                getSharedPreferences());
    }

    @Override
    protected void onCleared() {
        super.onCleared();
    }
}
